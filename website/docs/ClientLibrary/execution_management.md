---
id: execution_management
title: Execution Management
---

## **緖言**

リアルタイム制約がある環境下の予測可能な実行は多くのロボティクスアプリケーションにおいて重要な要件になっている。ROSのサービスをベースにするパラダイムは様々な機能の統合に優れているが、実行マネジメントにおいて十分な制御方法を用意していない。たとえば、ノード内のコールバックを特定な順番で実行させる機能を備えていない。そして制御アプリケーションにおいてマルチノードの実行順番は移動ロボティクスにとっては必須となる。取得したセンサーデータで構成される因果連鎖、データの評価および起動制御はそのままの順番でROSノードにマッピングされるべきだが、しかしそれを実行する明示的な機構は存在しない。さらに、フィードテスト用にインプットデータを集め、ROS-bagsに保存しリプレイしたら、非決定的なプロセススケジューリングのせいでいつも違う結果になるでしょう。

手動でコールバック内で特定の購読と配信の実行順序を設定することあるいは対応のLinuxプロセスの優先順位を微調整することは可能だが、
この方法でエラーを起こしやすくて拡張しにくい上に、システム内のROS 2パッケージの構成に深い知識が必要とされる。

そのためにリアルタイムエグゼキューターのゴールは以下のようなソリューションを提供する実用的で使いやすいリアルタイム機構を備えるロボティクスをサポートすることだ：

* 決定論的実行
* リアルタイム保証
* リアルタイムと非リアルタイム機能を１つのプラットフォームに統合する
* 特定のRTOSとマイクロコントローラーへのサポート

ROS 1ではネットワークスレッドはすべてのメッセージを受け取り、FIFOキュー（roscpp内）に入れることを担っている。それはつまり、すべてのコールバックはFIFO方式で実行され、実行管理を行うことはできない。DDS(data distribution service)の導入によって、ROS2ではメッセージがDDSにバッファーされるようになった。ROS2のエグゼキューターは優先順位度付けのように実行管理をサポートできるようになった。rclレイヤーにおいて、wait-setがハンドルにより設定され、次の後ハンドルがDDSキューから取り出される。ハンドルの実態はrclレイアにあるタイマー、購読者、クライアントとサービスなどの要約となる。

スタンダードROS 2 C++ API (rclcpp)のエグゼキューターの実装はいくつか尋常ではない特徴を持っている、たとえば他のすべてのDDSハンドルより優先順位は高いタイマー、ノンプリエンプティブでラウンドロビンスケジューリング仕様のノンタイマーハンドル、そしてハンドルごとに1個の入力データしか設けられない。（たとえマルチモードでも）これらの要素のせいで、特定の環境下ではスタンダードrclcppのエグゼキューターは決定論的ではなくなり、リアルタイム性の保証は難しくなる。私たちは通常CあるいはC++が動くマイクロコントローラープラットフォームを想定しているためPython API (rclpy)の実装を確認していない。 

リアルタイムエグゼキューターのゴールとROS 2スタンダードrclcppエグゼキューターの制限を総合的に考えると、挑むべき課題は：

* ROS 2フレームワークとリアルタイムシステム（RTOS）のために適切で明確に定義されたスケジューリング機構の開発
* ROS開発者向けの使いやすいインタフェースの設計
* 要件のモジュール化 (たとえばレイテンシ、サブシステム内の決定論)
* ROSフレームワークとOSスケジュラーのマッピング（半自動と最適的マッピングおよび汎用性を持つ、理解しやいフレームワーク機構を持つことが望まれる）

１つのアプローチはセクション「Introduction to Client Library」で言及したように２つのレイヤー上にリアルタイムエグゼキューターを提供する。１つはC言語で書かれたrclレイヤーでもう１つはC++で書かれたrclcppをベースにする。

最初のステップとして、Cでの論理的実行時間セマンティック付きの静的順序スケジューリングポリシーの実装を持つLETエグゼキューターを計画している。このスケジューリングポリシーの中で、すべてのコールバックが事前に定義した順番で実行される。LETのコンセプトとは、まずタスクが実行される前に入力データを読み込む。次に開発済みのコールバックグループレベルエグゼキューターでコールバックの優先順位を付けられるようになる。これらのアプローチはエグゼキューターに基づいていて、ROS 2に導入され済みである。

将来は的には、rclとrclcppレイヤに別のリアルタイムグゼキューターを提供するつもりだ。

## **rclcppスタンダードエグゼキューターの分析**

ROS2は１つのプロセスにマルチノードを使うことができる。プロセス内ノードのコールバックを調整するために、エグゼキューターのコンセプトをrclcpp（rclpyも）に実装した。　

ROS 2のデザインではプロセスごとに１つのエグゼキューター（rclcpp::executor::Executorのインスタンス）と定義している、それは通常カスタムメイン関数あるいはランチシステムに作成することは多い。エグゼキューターはDDSキュー内のすべての実行可能状態（タイマー、サービス、メッセージ、購読、etc.）をチェックすることでノードに登録されるコールバックの実行調整を行い、SingleThreadedExecutorとMultiThreadedExecutorに定義されている１つあるいは複数のスレッドに渡す。

ディスパッチング機構はROS 1のスピンスレッドの挙動と似ている：エグゼキューターは待機集合を確認し、DDSキュー内の保留中コールバックを通知してくれる。もし保留中のコールバックは複数ある場合はROS 2エグゼキューターは登録順で実行する。

## **アーキテクチャー**

下図はスタンダードROS 2エグゼキューター実装の関連クラスを描いている：

(diagram)

注意する必要あるのはエグゼキューターのインスタンスはNodeBaseInterfacesの弱参照を保持しているだけなので、エグゼキューターに通知せずとも
ノードを安全に削除することをできる。

また、エグゼキューターは明示的なコールバックキューを保持しないが、下図で示したように裏のDDS実装によるキュー機構に依存している：

(diagram)

つまり、エグゼキューターのコンセプトはコールバックに対する優先順位付けあるいは仕分けの方法を提供しない。
さらに、OSスケジュラーのリアルタイムの特性を使わず、より細かい実行順序のコントロールはできない。これによる全体への影響はタイムクリティカルなコールバックはタイムリミットに間に合わない、そしてタイムクリティカルなコールバックよりも遅く実行されることでパフォーマンスの劣化を招く。さらに、FIFO機構のため、すべてのコールバック実行に発生しうる最大待ち時間の境目を決めにくくなる。

## **スケジューリング セマンティクス**

CB2019のある論文では、rclcppエグゼキューターが細部まで分析済みで因果連鎖の応答時間に関する分析も行われる予定となる。エグゼキューターは
４つの違うコールバックを識別できる：システムタイマーがトリガーのタイマー、購読トピックにおける新しいメッセージがトリガーの購読者、サービスリクエストがトリガーのサービスとサービスレスポンスがトリガーのクライアント。エグゼキューターはDDSレイアのインプットキューからのメッセージの受信と対応のコールバックの実行を管理する。コールバックを実行すると、ノンプリエンプティブスケジュラーですべての実行可能タスクを考慮しないが、readySetと呼ばれる１つのスナップショットだけがエグゼキューターはアイドル状態になる時に更新され、このステップでDDSレイアと通信し実行可能タスクをアップデートする。すべてのタイプのタスクに専用のキューが用意ていて（タイマー、購読者、サービス、クライアント）順番に実行される。以下の不具合は要注意：