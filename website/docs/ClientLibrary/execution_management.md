---
id: execution_management
title: Execution Management
---

## **緖言**

リアルタイム制約がある環境下の予測可能な実行は多くのロボティクスアプリケーションにおいて重要な要件になっている。ROSのサービスをベースにするパラダイムは様々な機能の統合に優れているが、実行マネジメントにおいて十分な制御方法を用意していない。たとえば、ノード内のコールバックを特定な順番で実行させる機能を備えていない。そして制御アプリケーションにおいてマルチノードの実行順番は移動ロボティクスにとっては必須となる。取得したセンサーデータで構成される因果連鎖、データの評価および起動制御はそのままの順番でROSノードにマッピングされるべきだが、しかしそれを実行する明示的な機構は存在しない。さらに、フィードテスト用にインプットデータを集め、ROS-bagsに保存しリプレイしたら、非決定的なプロセススケジューリングのせいでいつも違う結果になるでしょう。

手動でコールバック内で特定の購読と配信の実行順序を設定することあるいは対応のLinuxプロセスの優先順位を微調整することは可能だが、
この方法でエラーを起こしやすくて拡張しにくい上に、システム内のROS 2パッケージの構成に深い知識が必要とされる。

そのためにリアルタイムエグゼキューターのゴールは以下のようなソリューションを提供する実用的で使いやすいリアルタイム機構を備えるロボティクスをサポートすることだ：

* 決定論的実行
* リアルタイム保証
* リアルタイムと非リアルタイム機能を１つのプラットフォームに統合する
* 特定のRTOSとマイクロコントローラーへのサポート

ROS 1ではネットワークスレッドはすべてのメッセージを受け取り、FIFOキュー（roscpp内）に入れることを担っている。それはつまり、すべてのコールバックはFIFO方式で実行され、実行管理を行うことはできない。DDS(data distribution service)の導入によって、ROS2ではメッセージがDDSにバッファーされるようになった。ROS2のエグゼキューターは優先順位度付けのように実行管理をサポートできるようになった。rclレイヤーにおいて、wait-setがハンドルにより設定され、次の後ハンドルがDDSキューから取り出される。ハンドルの実態はrclレイアにあるタイマー、購読者、クライアントとサービスなどの要約となる。

スタンダードROS 2 C++ API (rclcpp)のエグゼキューターの実装はいくつか尋常ではない特徴を持っている、たとえば他のすべてのDDSハンドルより優先順位は高いタイマー、ノンプリエンプティブでラウンドロビンスケジューリング仕様のノンタイマーハンドル、そしてハンドルごとに1個の入力データしか設けられない。（たとえマルチモードでも）これらの要素がもたらした結果は、特定の環境下ではスタンダードrclcppのエグゼキューターは決定論的ではなくなり、リアルタイム性の保証は難しくなる。私たちは通常CあるいはC++が動くマイクロコントローラープラットフォームを想定しているためPython API (rclpy)の実装を確認していない。 