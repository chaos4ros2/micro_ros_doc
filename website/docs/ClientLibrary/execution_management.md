---
id: execution_management
title: Execution Management
---

## **緖言**

リアルタイム制約がある環境下の予測可能な実行は多くのロボティクスアプリケーションにおいて重要な要件になっている。ROSのサービスをベースにするパラダイムは様々な機能の統合に優れているが、実行マネジメントにおいて十分な制御方法を用意していない。たとえば、ノード内のコールバックを特定な順番で実行させる機能を備えていない。そして制御アプリケーションにおいてマルチノードの実行順番は移動ロボティクスにとっては必須となる。取得したセンサーデータで構成される因果連鎖、データの評価および起動制御はそのままの順番でROSノードにマッピングされるべきだが、しかしそれを実行する明示的な機構は存在しない。さらに、フィードテスト用にインプットデータを集め、ROS-bagsに保存しリプレイしたら、非決定的なプロセススケジューリングのせいでいつも違う結果になるでしょう。

手動でコールバック内で特定の購読と配信の実行順序を設定することあるいは対応のLinuxプロセスの優先順位を微調整することは可能だが、
この方法でエラーを起こしやすくて拡張しにくい上に、システム内のROS 2パッケージの構成に深い知識が必要とされる。

そのためにリアルタイムエグゼキューターのゴールは以下のようなソリューションを提供する実用的で使いやすいリアルタイム機構を備えるロボティクスをサポートすることだ：

* 決定論的実行
* リアルタイム保証
* リアルタイムと非リアルタイム機能を１つのプラットフォームに統合する
* 特定のRTOSとマイクロコントローラーへのサポート

ROS 1ではネットワークスレッドはすべてのメッセージを受け取り、FIFOキュー（roscpp内）に入れることを担っている。それはつまり、すべてのコールバックはFIFO方式で実行され、実行管理を行うことはできない。DDS(data distribution service)の導入によって、ROS2ではメッセージがDDSにバッファーされるようになった。ROS2のエグゼキューターは優先順位度付けのように実行管理をサポートできるようになった。rclレイヤーにおいて、wait-setがハンドルにより設定され、次の後ハンドルがDDSキューから取り出される。ハンドルの実態はrclレイアにあるタイマー、購読者、クライアントとサービスなどの要約となる。

スタンダードROS 2 C++ API (rclcpp)のエグゼキューターの実装はいくつか尋常ではない特徴を持っている、たとえば他のすべてのDDSハンドルより優先順位は高いタイマー、ノンプリエンプティブでラウンドロビンスケジューリング仕様のノンタイマーハンドル、そしてハンドルごとに1個の入力データしか設けられない。（たとえマルチモードでも）これらの要素のせいで、特定の環境下ではスタンダードrclcppのエグゼキューターは決定論的ではなくなり、リアルタイム性の保証は難しくなる。私たちは通常CあるいはC++が動くマイクロコントローラープラットフォームを想定しているためPython API (rclpy)の実装を確認していない。 

リアルタイムエグゼキューターのゴールとROS 2スタンダードrclcppエグゼキューターの制限を総合的に考えると、挑むべき課題は：

* ROS 2フレームワークとリアルタイムシステム（RTOS）のために適切で明確に定義されたスケジューリング機構の開発
* ROS開発者向けの使いやすいインタフェースの設計
* 要件のモジュール化 (たとえばレイテンシ、サブシステム内の決定論)
* ROSフレームワークとOSスケジュラーのマッピング（半自動と最適的マッピングおよび汎用性を持つ、理解しやいフレームワーク機構を持つことが望まれる）

１つのアプローチはセクション「Introduction to Client Library」で言及したように２つのレイヤー上にリアルタイムエグゼキューターを提供する。１つはC言語で書かれたrclレイヤーでもう１つはC++で書かれたrclcppをベースにする。

最初のステップとして、Cでの論理的実行時間セマンティック付きの静的順序スケジューリングポリシーの実装を持つLETエグゼキューターを計画している。このスケジューリングポリシーの中で、すべてのコールバックが事前に定義した順番で実行される。LETのコンセプトとは、まずタスクが実行される前に入力データを読み込む。次に開発済みのコールバックグループレベルエグゼキューターでコールバックの優先順位を付けられるようになる。これらのアプローチはエグゼキューターに基づいていて、ROS 2に導入され済みである。

将来は的には、rclとrclcppレイヤに別のリアルタイムグゼキューターを提供するつもりだ。

## **rclcppスタンダードエグゼキューターの分析**

ROS2は１つのプロセスにマルチノードを使うことができる。プロセス内ノードのコールバックを調整するために、エグゼキューターのコンセプトをrclcpp（rclpyも）に実装した。　

ROS 2のデザインではプロセスごとに１つのエグゼキューター（rclcpp::executor::Executorのインスタンス）と定義している、それは通常カスタムメイン関数あるいはランチシステムに作成することは多い。エグゼキューターはDDSキュー内のすべての実行可能状態（タイマー、サービス、メッセージ、購読、etc.）をチェックすることでノードに登録されるコールバックの実行調整を行い、SingleThreadedExecutorとMultiThreadedExecutorに定義されている１つあるいは複数のスレッドに渡す。

ディスパッチング機構はROS 1のスピンスレッドの挙動と似ている：エグゼキューターは待機集合を確認し、DDSキュー内の保留中コールバックを通知してくれる。もし保留中のコールバックは複数ある場合はROS 2エグゼキューターは登録順で実行する。

## **アーキテクチャー**

下図はスタンダードROS 2エグゼキューター実装の関連クラスを描いている：

(diagram)

注意する必要あるのはエグゼキューターのインスタンスはNodeBaseInterfacesの弱参照を保持しているだけなので、エグゼキューターに通知せずとも
ノードを安全に削除することをできる。

また、エグゼキューターは明示的なコールバックキューを保持しないが、下図で示したように裏のDDS実装によるキュー機構に依存している：

(diagram)

つまり、エグゼキューターのコンセプトはコールバックに対する優先順位付けあるいは仕分けの方法を提供しない。
さらに、OSスケジュラーのリアルタイムの特性を使わず、より細かい実行順序のコントロールはできない。これによる全体への影響はタイムクリティカルなコールバックはタイムリミットに間に合わない、そしてタイムクリティカルなコールバックよりも遅く実行されることでパフォーマンスの劣化を招く。さらに、FIFO機構のため、すべてのコールバック実行に発生しうる最大待ち時間の境目を決めにくくなる。

## **スケジューリング セマンティクス**

CB2019のある論文では、rclcppエグゼキューターが細部まで分析済みで因果連鎖の応答時間に関する分析も行われる予定となる。エグゼキューターは
４つの違うコールバックを識別できる：システムタイマーがトリガーのタイマー、購読トピックにおける新しいメッセージがトリガーの購読者、サービスリクエストがトリガーのサービスとサービスレスポンスがトリガーのクライアント。エグゼキューターはDDSレイアのインプットキューからのメッセージの受信と対応のコールバックの実行を管理する。コールバックを実行すると、ノンプリエンプティブスケジュラーですべての実行可能タスクを考慮しないが、readySetと呼ばれる１つのスナップショットだけがエグゼキューターはアイドル状態になる時に更新され、このステップでDDSレイアと通信し実行可能タスクをアップデートする。すべてのタイプのタスクに専用のキューが用意ていて（タイマー、購読者、サービス、クライアント）順番に実行される。以下の不具合は要注意：

* タイマーが最高の優先度を持つ。エグゼキューターのタイマープロセスはいつも最初に実行される。これによる影響は、過負荷状態下ではDDSキューが実行されない。
* ノンタイマーハンドルではノンプリエンプティブでラウンドロビンスケジューリング形式を採用している。プロセス進行中受信したメッセージが残ったコールバックはすべて実行されるまでに考慮されない。これによる影響としては優先順位の反転がある、低優先順位のコールバックは暗黙のうちに高優先順位のコールバックをブロックするかもしれない。
* 毎回のハンドルで扱えるメッセージは１つだけ。レディセットには１つのタスクインスタンスしか含まれてなく、例えば、同じトピックにマルチメッセージが届いても、エグゼキューターは再びアイドル状態になり、レディセットがDDSレイアで更新されるまで１つのインスタンスしかそれらを処理できない。これは優先順位逆転を悪化させる。未完了のコールバックはスケジューリングが検討されるまでレディセットのマルチプロセスを待たさないといけない。つまり非タイムコールバックのインスタンスが、同じ優先度の低いコールバックのマルチインスタンスによってブロックされてしまう可能性がある。

参照：[レディセット](https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf)

これらの発見により、著者らは、決定論を提供するための代替アプローチを提示し、ROS 2システムによく知られたスケジューラビリティー分析を適用するための代替手法を提案する。予約ベースのスケジューリングでの応答時間に対する解析である。

## **RCLCエグゼキューター**

ここではC言語で書かれたアプリケーションのためのrclcエグゼキューターを紹介する、rclcエグゼキューターはrcl APIに基づいて実装され、rcl API
のためのROS 2 Executorである。組込みアプリケーションでは、エンド・ツー・エンドのレイテンシーを保証するためにリアルタイム性が要求されたり、テストデータを正しく再検証するために決定性のあるランタイム動作が必要になることがある。しかし、デフォルトのROS 2エグゼキューターは前のセクションで説明したように、その複雑なセマンティクスのせいでそれを達成するのは困難である。

まず、そのようなアプリケーションの要件を分析し、次に、決定論的かつリアルタイムな動作を可能にするためのエクゼキュータの簡単な機能を導き出す。

## **依存関係分析**

最初に、組み込み分野での使用例を説明する。この分野では、決定性とリアルタイム性を保証するために、タイムトリガーのパラダイムがよく使われる。次に、決定性のある動作を可能にする移動ロボットのソフトウェアデザインパターンを分析する。

リアルタイムの組込みアプリケーションのユースケース

組込みシステムでは、リアルタイム性を追求するために、定期的にプロセスをアクティブにするタイムトリガー方式を採用している。
プロセスには優先順位をつけて、プリエンプションを可能にすることができる。図1はその一例で、一定の周期を持つ3つのプロセスを示している。
中段と下段のプロセスは、空の破線で示されたように、複数回プリエンプションされている。

(Figure 1)

図1 : 固定周期のプリエンプティブ・スケジューリング

各プロセスには、図2に示すように、1つまたは複数のタスクを割り当てることができる。これらのタスクは順次実行されていき、協調型スケジューリングと呼ばれている。

(Figure 2)

図2 : 順次実行されるタスクを持つプロセス

与えられた数のプロセスに優先度を割り当てる方法はさまざまですが、プロセッサの使用率が低い場合には、周期が短いプロセスほど優先度が高くなるレートモノトニックスケジューリング方式のスケジューリング割り当てが最適であることがわかっていて、プロセッサの使用率が69%以下の場合に最適であることが示されている LL1973。

ここ数十年たくさんのスケジューリング方法が開発されてきたが、固定周期のプリエンプティブスケジューリングは以前組込みリアルタイムシステム内で広く使われている KZH2015。リアルタイムシステムの特徴を見るとその理由は明らかになる。Linuxと同様、NuttX, Zephyr, FreeRTOS, QNXなどリアルタイムシステムも固定周期のプリエンプティブスケジューリングをサポートし、そして優先度を割り当てることができる。(つまりタイムトリガーパラダイムが内包される設計となる。)この分野ではタイムトリガーのパラダイムが主流の設計原理となっている。

しかし、プリエンプティブスケジューリングが使用され、しかもデータがグローバル変数を通じてマルチプロセス間で共有される場合はデータの一貫性はいつも問題となる。スケジューリング効果およびプロセスの実行時間の変化によってこれらの変数の書き込みと読み取りのタイミングはたまに前後してしまう。これによってアップデート時の遅延は発生してしまう（ある変数は他のプロセスの変数になるタイミング）。マルチプロセスで同じタイミングで変数にアクセスする時に競合を発生してしまう。この問題を解決するために、理論実行時間（LET）がHHK2001で紹介され、事前に定義した周期のタイムインスタンスでのみデータの通信が行われる：読み取りは周期の始めのみで書き込みは周期の終わりのみとなる。遅延時間の増加によるコストと引き換えに、データの一貫性の保持とジッターの軽減が持たされている。このコンセプトは、最近では自動車のアプリケーションにも使われている NSP2018。

図3にLETコンセプトの例を示している。二つのプロセスは１つのグローバル変数を通じてデータのやり取りをすると仮定する。このデータが書き込まれるタイムポイントはプロセスの最後になる。一般のケースでは（左側）、プロセスp3とP4はアップデートを受け取る。図の右側では同じシナリオでLETセマンティック付きのケースとなる。データは周期の境界線にのみ通信を行う。このケースの場合、下のプロセスと周期の終端と通信をしているため、いつまでもプロセスp3とp5が新しいデータを受信する。

組込みでのユースケースは以下のコンセプトに基づいている：
* プロセスの定期的な実行
* プロセスへの固定的な優先順位の割り当て
* プロセスのプリエンプティブ・スケジューリング
* プロセス内のタスクを協調してスケジューリングすること（逐次実行）
* LETセマンティクスによるデータ同期

ROS2ではタイマーを使った周期的な起動が可能である同時にOSではプリエンプティブなスケジューリングがサポートされていて、ROSのノードに対応するスレッド/プロセスの粒度で優先度を割り当てることができる。データに依存しないコールバックを順次に実行することはできない。さらに、データがコールバックが実行される前にDDSキューから読み取られ、アプリケーション実行中のあるタイミングで書き込まれる。rclcppエグゼキューターの
スピン周期関数は固定の周期でデータをチェックし、データが使用可能状態になるとコールバックを実行させることができる。しかしスピン周期関数はすべてのコールバック関数を実行するわけではないため、定期的にコールバックを実行することに役に立たない（別名：プロセス付きタスク）。そのためタイマーをベースにするマルチコールバック（別名：タスク）の実装をトリガーできる機構が必要だ。データ転送はDDSによって提供されてLETセマンティクスの実装はできない。要約して以下の要件を導き出した：

派生した要件：
* 複数コールバック実行をトリガーする
* コールバックの順次処理
* LETセマンティクスによるデータ同期

ロボティクスにおける認知・判断・操作パイプライン

ここでは、決定性のある動作を実現するために、移動ロボティクスで使用される一般的なソフトウェアデザインパターンについて説明する。個々の
デザインパータンのコンセプトおよび決定性のあるエグゼキューター向けの派生要件を述べる。コンセプト：

移動ロボティクスにおける一般的なデザインパラダイムは制御ループでいくつかのフェーズに構成されている：センサーからデータを取得する認知フェーズ、位置推定や経路計画の判断フェーズおよび移動ロボットを操縦する操作フェーズ。もちろんフェーズを追加することも可能だが例としてこれら三つのフェーズのみ使用する。そのような時のパイプラインは図4に示す。

(Figure 4)

図4：マルチセンサーが認知・判断・操作パイプラインを動かす。

通常マルチセンサーは環境を認識するために使われる。たとえばIMUとレーザースキャンナー。自己位置推定のアルゴリズムの精度は処理時のセンサーデータのリアルタイム性に大きく依存する。理想なのはすべてのセンサーの最新のデータがすべて処理されることである。それを達成する方法の１つは認知フェーズですべてのセンサードライバーを実行し、判断フェーズですべてのアルゴリズムを実行させる。

現在、デフォルトのROS2エグゼキューターではプロセスの順番を定義することはできない。原則上データドリブンパイプラインをデザインすることは
できるが、しかし、例えばレーザースキャン中の認知フェーズでも判断フェーズと同じくコールバックが必要な時があるしょう。それら購読者のプロセス順番は任意になってしまう。

この認知・判断・操作パータンに対応するために、個々のフェーズのためにエグゼキューターを定義する。判断フェーズは認知フェーズのすべての
コールバック処理が終了後にトリガーされる。

派生した要件：
* コールバックのトリガー実行