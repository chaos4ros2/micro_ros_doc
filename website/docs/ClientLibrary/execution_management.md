---
id: execution_management
title: Execution Management
---

## **緖言**

リアルタイム制約がある環境下の予測可能な実行は多くのロボティクスアプリケーションにおいて重要な要件になっている。ROSのサービスをベースにするパラダイムは様々な機能の統合に優れているが、実行マネジメントにおいて十分な制御方法を用意していない。たとえば、ノード内のコールバックを特定な順番で実行させる機能を備えていない。そして制御アプリケーションにおいてマルチノードの実行順番は移動ロボティクスにとっては必須となる。取得したセンサーデータで構成される因果連鎖、データの評価および起動制御はそのままの順番でROSノードにマッピングされるべきだが、しかしそれを実行する明示的な機構は存在しない。さらに、フィードテスト用にインプットデータを集め、ROS-bagsに保存しリプレイしたら、非決定的なプロセススケジューリングのせいでいつも違う結果になるでしょう。

手動でコールバック内で特定の購読と配信の実行順序を設定することあるいは対応のLinuxプロセスの優先順位を微調整することは可能だが、
この方法でエラーを起こしやすくて拡張しにくい上に、システム内のROS 2パッケージの構成に深い知識が必要とされる。

そのためにリアルタイムエグゼキューターのゴールは以下のようなソリューションを提供する実用的で使いやすいリアルタイム機構を備えるロボティクスをサポートすることだ：

* 決定論的実行
* リアルタイム保証
* リアルタイムと非リアルタイム機能を１つのプラットフォームに統合する
* 特定のRTOSとマイクロコントローラーへのサポート

ROS 1ではネットワークスレッドはすべてのメッセージを受け取り、FIFOキュー（roscpp内）に入れることを担っている。それはつまり、すべてのコールバックはFIFO方式で実行され、実行管理を行うことはできない。DDS(data distribution service)の導入によって、ROS2ではメッセージがDDSにバッファーされるようになった。ROS2のエグゼキューターは優先順位度付けのように実行管理をサポートできるようになった。rclレイヤーにおいて、wait-setがハンドルにより設定され、次の後ハンドルがDDSキューから取り出される。ハンドルの実態はrclレイアにあるタイマー、購読者、クライアントとサービスなどの要約となる。

スタンダードROS 2 C++ API (rclcpp)のエグゼキューターの実装はいくつか尋常ではない特徴を持っている、たとえば他のすべてのDDSハンドルより優先順位は高いタイマー、ノンプリエンプティブでラウンドロビンスケジューリング仕様のノンタイマーハンドル、そしてハンドルごとに1個の入力データしか設けられない。（たとえマルチモードでも）これらの要素のせいで、特定の環境下ではスタンダードrclcppのエグゼキューターは決定論的ではなくなり、リアルタイム性の保証は難しくなる。私たちは通常CあるいはC++が動くマイクロコントローラープラットフォームを想定しているためPython API (rclpy)の実装を確認していない。 

リアルタイムエグゼキューターのゴールとROS 2スタンダードrclcppエグゼキューターの制限を総合的に考えると、挑むべき課題は：

* ROS 2フレームワークとリアルタイムシステム（RTOS）のために適切で明確に定義されたスケジューリング機構の開発
* ROS開発者向けの使いやすいインタフェースの設計
* 要件のモジュール化 (たとえばレイテンシ、サブシステム内の決定論)
* ROSフレームワークとOSスケジュラーのマッピング（半自動と最適的マッピングおよび汎用性を持つ、理解しやいフレームワーク機構を持つことが望まれる）

１つのアプローチはセクション「Introduction to Client Library」で言及したように２つのレイヤー上にリアルタイムエグゼキューターを提供する。１つはC言語で書かれたrclレイヤーでもう１つはC++で書かれたrclcppをベースにする。

最初のステップとして、Cでの論理的実行時間セマンティック付きの静的順序スケジューリングポリシーの実装を持つLETエグゼキューターを計画している。このスケジューリングポリシーの中で、すべてのコールバックが事前に定義した順番で実行される。LETのコンセプトとは、まずタスクが実行される前に入力データを読み込む。次に開発済みのコールバックグループレベルエグゼキューターでコールバックの優先順位を付けられるようになる。これらのアプローチはエグゼキューターに基づいていて、ROS 2に導入され済みである。

将来は的には、rclとrclcppレイヤに別のリアルタイムグゼキューターを提供するつもりだ。

## **rclcppスタンダードエグゼキューターの分析**

ROS2は１つのプロセスにマルチノードを使うことができる。プロセス内ノードのコールバックを調整するために、エグゼキューターのコンセプトをrclcpp（rclpyも）に実装した。　

ROS 2のデザインではプロセスごとに１つのエグゼキューター（rclcpp::executor::Executorのインスタンス）と定義している、それは通常カスタムメイン関数あるいはランチシステムに作成することは多い。エグゼキューターはDDSキュー内のすべての実行可能状態（タイマー、サービス、メッセージ、購読、etc.）をチェックすることでノードに登録されるコールバックの実行調整を行い、SingleThreadedExecutorとMultiThreadedExecutorに定義されている１つあるいは複数のスレッドに渡す。

ディスパッチング機構はROS 1のスピンスレッドの挙動と似ている：エグゼキューターは待機集合を確認し、DDSキュー内の保留中コールバックを通知してくれる。もし保留中のコールバックは複数ある場合はROS 2エグゼキューターは登録順で実行する。

## **アーキテクチャー**

下図はスタンダードROS 2エグゼキューター実装の関連クラスを描いている：


